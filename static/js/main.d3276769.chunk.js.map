{"version":3,"sources":["components/logo.svg","hooks/contexts/base/Combine.tsx","logics/renderLayers.ts","hooks/contexts/base/order.ts","hooks/contexts/base/createReducer.ts","hooks/contexts/counter/reducer.ts","hooks/contexts/counter/actions.ts","hooks/contexts/counter/index.ts","hooks/contexts/fetch/reducer.ts","hooks/contexts/fetch/actions.ts","hooks/contexts/index.tsx","hooks/contexts/fetch/index.ts","components/Counter.tsx","components/Fetch.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Component","children","providers","reduceRight","acc","Provider","displayName","order","REDUCER","Symbol","ACTIONS","INTEGRATED","renderLayers","layers","reduce","key","list","flatMap","x","options","initial","name","reducer","Container","createContainer","React","useReducer","increment","set","createReducer","counter","state","action","type","payload","useContainer","dispatch","Object","freeze","useCallback","value","actions","add","clear","items","timeAsync","a","started","Date","now","request","Request","fetch","json","counterReducer","addAsync","time","counterContext","Combine","DOM","onChangeCounter","onClickAdd","htmlFor","defaultValue","id","onChange","onClick","counterActions","e","Number","parseInt","currentTarget","useSideEffect","onClickClear","onClickFetch","length","map","index","fetchActions","fetchReducer","className","src","logo","alt","Counter","Fetch","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.d3276769.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\nimport type { ContainerProviderProps } from 'unstated-next';\n\n/** コンポーネントの要求する型定義。 */\nexport interface Props {\n  /** コンテキスト プロバイダー一覧。 */\n  readonly providers?: readonly Provider[];\n}\n\n/** コンテキストのプロバイダー型の短縮表記。 */\nexport type Provider = React.ComponentType<ContainerProviderProps>;\n\n/** プロバイダー一覧を単純結合する HOC コンポーネント。 */\nconst Component: React.FC<Props> = ({ children, providers = [] }) =>\n  // Decorator パターンのように、後の要素をラッピングしていく構造のため、`reduceRight` で反転している。\n  providers.reduceRight(\n    (acc, Provider) => <Provider>{acc}</Provider>,\n    <>{children}</>\n  );\nComponent.displayName = 'Combine';\n\nexport default Component;\n","/**\n * レイヤー構造として要求する型定義。\n * @template R レイヤーの優先度として、使用する型。\n * @template T レイヤー本体の型。\n */\nexport type Layer<R extends PropertyKey, T> = Readonly<\n  Partial<Record<R, T | readonly T[]>>\n>;\n\n/**\n * 指定した引数をルールに、レイヤー結合関数を生成します。\n * @template R レイヤーの優先度として、使用する型。\n *\n * キーとして列挙可能な型のみ使用可能です。\n * @param order ルールとするレイヤー定義と優先度を示した配列。\n *\n * インデックスが先頭の要素ほど、先頭に配置します。\n */\nexport default <R extends PropertyKey>(order: readonly R[]) =>\n  /**\n   * レイヤーを結合して、単一の配列を生成します。\n   * @template T レイヤーの型。\n   * @param layers レイヤー別に分類した、値もしくは値の一覧。\n   */\n  <T>(...layers: Layer<R, T>[]) =>\n    order.reduce<T[]>((acc, key) => {\n      const list = layers.flatMap((x): T | readonly T[] => x[key] ?? []);\n      return [...acc, ...list];\n    }, []);\n","import renderLayers, { Layer } from '../../../logics/renderLayers';\n\n/** リデューサー コンテキストのレイヤーを示す定数。 */\nexport const REDUCER = Symbol('reducer');\n\n/** アクション コンテキストのレイヤーを示す定数。 */\nexport const ACTIONS = Symbol('actions');\n\n/** 結合のための上位アクション コンテキストのレイヤーを示す定数。 */\nexport const INTEGRATED = Symbol('integrated');\n\n/**\n * レイヤー結合のための優先度ルール。\n *\n * インデックスが若いものほど、より上位のレイヤーとなります。\n */\nconst orderRule = [REDUCER, ACTIONS, INTEGRATED] as const;\n\n/**\n * レイヤー構造として要求する型定義。\n * @template T レイヤー本体の型。\n */\nexport type ConcretedLayer<T> = Layer<typeof orderRule[number], T>;\n\nexport default renderLayers(orderRule);\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\n\n/**\n * リデューサーへ渡す値の型定義。\n *\n * `P` の型を省略するか、`undefined` を指定した場合、ペイロードは\n * _optional_ となります。つまりペイロードの指定自体が省略可能となります。\n * @template T 識別子の型。\n * @template P ペイロードの型。\n */\nexport type Action<T extends PropertyKey, P = undefined> = Readonly<\n  ActionType<T> & (P extends undefined ? Partial<Payload<P>> : Payload<P>)\n>;\n\n/**\n * リデューサーへ渡す値における、識別子部分の型定義。\n * @template T 識別子の型。\n */\ninterface ActionType<T extends PropertyKey> {\n  /** 識別子。 */\n  readonly type: T;\n}\n\n/**\n * リデューサー コンテキストを作成するためのオプション一覧。\n * @template S 状態の型。\n * @template A アクションの型。\n */\nexport interface CreateReducerOptions<S, A> {\n  /** 初期状態。 */\n  readonly initial: Readonly<S>;\n  /**\n   * コンテキストをラッピングする、コンポーネント名。\n   *\n   * 省略しても問題ありませんが、デバッグ時に有用です。\n   */\n  readonly name?: string;\n  /** リデューサー関数。 */\n  readonly reducer: React.Reducer<S, A>;\n}\n\n/**\n * リデューサーへ渡す値における、ペイロード部分の型定義。\n * @template T ペイロードの型。\n */\ninterface Payload<T> {\n  /** ペイロード本体。 */\n  readonly payload: T;\n}\n\n/**\n * リデューサー コンテキストを作成します。\n * @template S 状態の型。\n * @template A アクションの型。\n * @param options オプション一覧。\n */\nexport default <S, A>(options: CreateReducerOptions<S, A>) => {\n  const { initial, name, reducer } = options;\n  const Container = createContainer(() => React.useReducer(reducer, initial));\n  if (name) {\n    Container.Provider.displayName = `[REDUCER] ${name}`;\n  }\n  return Container;\n};\n","import createReducer, { Action } from '../base/createReducer';\n\n/** カウンターのインクリメントを示す、識別定数。 */\nexport const increment = Symbol('increment');\n\n/** カウンターの上書きを示す、識別定数。 */\nexport const set = Symbol('set');\n\n/** カウンターの状態における、型定義。 */\nexport interface State {\n  /** カウンター。 */\n  readonly counter: number;\n}\n\n/** カウンター用のアクション パラメーター。 */\nexport type CounterAction =\n  | Action<typeof increment>\n  | Action<typeof set, number>;\n\n/** カウンター用のリデューサー コンテキスト。 */\nexport default createReducer<State, CounterAction>({\n  initial: { counter: 0 },\n  name: 'Counter',\n  reducer: (state, action) => {\n    switch (action.type) {\n      case increment:\n        return { ...state, counter: state.counter + 1 };\n      case set:\n        return { ...state, counter: action.payload };\n      default:\n        return state;\n    }\n  },\n});\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport reducer, { increment, set } from './reducer';\n\n/** カウンターにおける、アクションの型定義。 */\nexport interface Actions {\n  /** カウンターをインクリメントします。 */\n  readonly increment: () => void;\n  /** カウンターを指定の値で上書きします。 */\n  readonly set: (\n    /** 値。 */\n    value: number\n  ) => void;\n}\n\n/** カウンターにおける、アクションを作成します。 */\nconst useActions = () => {\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    increment: React.useCallback(() => dispatch({ type: increment }), [\n      dispatch,\n    ]),\n    set: React.useCallback(\n      (value: number) => dispatch({ type: set, payload: value }),\n      [dispatch]\n    ),\n  });\n};\n\n/** カウンターにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'CounterAction';\n\nexport default Container;\n","import type { Provider } from '../base/Combine';\nimport { ACTIONS, ConcretedLayer, REDUCER } from '../base/order';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nconst layers: ConcretedLayer<Provider> = {\n  [ACTIONS]: actions.Provider,\n  [REDUCER]: reducer.Provider,\n};\n\nexport default layers;\n","import createReducer, { Action } from '../base/createReducer';\n\n/** フェッチ ログの追加を示す、識別定数。 */\nexport const add = Symbol('add');\n/** フェッチ ログの全件削除を示す、識別定数。 */\nexport const clear = Symbol('clear');\n\n/** フェッチ ログの単体構造。 */\nexport interface Item {\n  /** 通信の所要時間を、ミリ秒単位で格納します。 */\n  readonly time: number;\n  /** 通信時における、カウンター値。 */\n  readonly counter: number;\n}\n\n/** フェッチ ログ状態における、型定義。 */\nexport interface State {\n  /** フェッチ ログ一覧。 */\n  readonly items: readonly Item[];\n}\n\n/** フェッチ用のアクション パラメーター。 */\nexport type FetchAction = Action<typeof add, Item> | Action<typeof clear>;\n\n/** フェッチ用のリデューサー コンテキスト。 */\nexport default createReducer<State, FetchAction>({\n  initial: { items: [] },\n  name: 'Fetch',\n  reducer: (state, action) => {\n    switch (action.type) {\n      case add:\n        return { ...state, items: [...state.items, action.payload] };\n      case clear:\n        return { ...state, items: [] };\n      default:\n        return state;\n    }\n  },\n});\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport counterReducer from '../counter/reducer';\nimport reducer, { add, clear } from './reducer';\n\n/** フェッチ ログにおける、アクションの型定義。 */\nexport interface Actions {\n  /** 非同期的にフェッチを行い、経過時間やその時のカウンター値をログに追加します。 */\n  readonly addAsync: () => Promise<void>;\n  /** フェッチ ログを全件削除します。 */\n  readonly clear: () => void;\n}\n\n/** 非同期的にフェッチを行い、所要時間をミリ秒単位で取得します。 */\nconst timeAsync = async () => {\n  const started = Date.now();\n  // 単に繋いでいる間待つだけ。単に非同期で動くことを検証したい\n  // だけの代物なので、ダミーウェイトで代用しても構わない。\n  const request = new Request('https://api.github.com/users/danmaq/repos');\n  await (await fetch(request)).json();\n  return Date.now() - started;\n};\n\n/** フェッチ ログにおける、アクションを作成します。 */\nconst useActions = () => {\n  const [{ counter }] = counterReducer.useContainer();\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    addAsync: React.useCallback(\n      async () =>\n        dispatch({ type: add, payload: { time: await timeAsync(), counter } }),\n      [counter, dispatch]\n    ),\n    clear: React.useCallback(() => dispatch({ type: clear }), [dispatch]),\n  });\n};\n\n/** フェッチ ログにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'FetchAction';\n\nexport default Container;\n","import React from 'react';\nimport CombinedContexts from './base/Combine';\nimport order from './base/order';\nimport counterContext from './counter';\nimport fetchContext from './fetch';\n\n/**\n * コンテキスト一覧。\n *\n * 別のコンテキストを追加する場合、ここに挿入します。\n *\n * 同一ヒエラルキーのコンテキストを参照したい場合、\n * 参照対象より末尾に指定します。\n */\nconst providers = order(counterContext, fetchContext);\n\n/** コンテキスト一覧をレンダリング ツリーに結合するための HOC。 */\nconst Component: React.FC = ({ children }) => (\n  <CombinedContexts providers={providers}>{children}</CombinedContexts>\n);\nComponent.displayName = 'Contexts';\n\nexport default Component;\n","import type { Provider } from '../base/Combine';\nimport { ACTIONS, ConcretedLayer, REDUCER } from '../base/order';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nconst layers: ConcretedLayer<Provider> = {\n  [ACTIONS]: actions.Provider,\n  [REDUCER]: reducer.Provider,\n};\n\nexport default layers;\n","import React from 'react';\nimport counterActions from '../hooks/contexts/counter/actions';\nimport counterReducer from '../hooks/contexts/counter/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** カウンターの値。 */\n  readonly counter: number;\n  /** カウンターを直接編集した際のコールバック。 */\n  readonly onChangeCounter?: React.ChangeEventHandler<HTMLInputElement>;\n  /** `+1` ボタンを押下した際のコールバック。 */\n  readonly onClickAdd?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\n/** カウンター表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({ counter, onChangeCounter, onClickAdd }) => (\n  <section>\n    <p>\n      Counter: <strong>{counter}</strong>\n    </p>\n    <label htmlFor=\"counter\">\n      Set counter:\n      <input\n        defaultValue={counter}\n        id=\"counter\"\n        name=\"counter\"\n        onChange={onChangeCounter}\n        type=\"number\"\n      />\n    </label>\n    <button onClick={onClickAdd} type=\"button\">\n      +1\n    </button>\n  </section>\n);\nDOM.displayName = 'CounterDOM';\n\n/** カウンター表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { increment, set } = counterActions.useContainer();\n  const [{ counter }] = counterReducer.useContainer();\n  return Object.freeze<DOMProps>({\n    counter,\n    onChangeCounter: React.useCallback(\n      (e) => set(Number.parseInt(e.currentTarget.value, 10)),\n      [set]\n    ),\n    onClickAdd: increment,\n  });\n};\n\n/** 副作用と結合した、カウンター表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const { counter, onChangeCounter, onClickAdd } = useSideEffect();\n  return (\n    <DOM\n      counter={counter}\n      onChangeCounter={onChangeCounter}\n      onClickAdd={onClickAdd}\n    />\n  );\n};\nComponent.displayName = 'Counter';\n\nexport default Component;\n","import React from 'react';\nimport fetchActions from '../hooks/contexts/fetch/actions';\nimport fetchReducer, { Item } from '../hooks/contexts/fetch/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** フェッチ結果一覧。 */\n  readonly items?: readonly Item[];\n  /** 一覧消去のボタンを押下した際における、コールバック。 */\n  readonly onClickClear?: React.MouseEventHandler<HTMLButtonElement>;\n  /** フェッチ ボタンを押下した際における、コールバック。 */\n  readonly onClickFetch?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\n/** フェッチ表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({\n  items = [],\n  onClickClear,\n  onClickFetch,\n}) => (\n  <section>\n    <button onClick={onClickFetch} type=\"button\">\n      Fetch to “api.github.com”\n    </button>\n    <button onClick={onClickClear} type=\"button\">\n      Clear the history\n    </button>\n    <ol>\n      {items.length ? (\n        items.map(({ counter, time }, index) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={index}>\n            It took <strong>{time}ms</strong> to fetch, and the counter was “\n            <strong>{counter}</strong>”.\n          </li>\n        ))\n      ) : (\n        <li>Empty data</li>\n      )}\n    </ol>\n  </section>\n);\nDOM.displayName = 'FetchDOM';\n\n/** フェッチ表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { addAsync, clear } = fetchActions.useContainer();\n  const [{ items }] = fetchReducer.useContainer();\n  return Object.freeze<DOMProps>({\n    items,\n    onClickClear: clear,\n    onClickFetch: addAsync,\n  });\n};\n\n/** 副作用と結合した、フェッチ表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const { items, onClickClear, onClickFetch } = useSideEffect();\n  return (\n    <DOM\n      items={items}\n      onClickClear={onClickClear}\n      onClickFetch={onClickFetch}\n    />\n  );\n};\nComponent.displayName = 'Fetch';\n\nexport default Component;\n","import React from 'react';\nimport Contexts from '../hooks/contexts';\nimport logo from './logo.svg';\nimport Counter from './Counter';\nimport Fetch from './Fetch';\nimport './App.css';\n\n/** ルート要素 コンポーネント。 */\nconst Component: React.FC = () => (\n  <Contexts>\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>Hello, world!</p>\n        <Counter />\n        <Fetch />\n      </header>\n    </div>\n  </Contexts>\n);\nComponent.displayName = 'App';\n\nexport default Component;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Component from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Component />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}