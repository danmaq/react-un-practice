{"version":3,"sources":["components/logo.svg","hooks/contexts/base/Combine.tsx","hooks/contexts/base/createCombineProps.ts","hooks/contexts/base/createReducer.ts","hooks/contexts/counter/reducer.ts","hooks/contexts/counter/actions.ts","hooks/contexts/counter/index.ts","hooks/contexts/fetch/reducer.ts","hooks/contexts/fetch/actions.ts","hooks/contexts/index.tsx","hooks/contexts/fetch/index.ts","components/Counter.tsx","components/Fetch.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Internal","children","providers","reduce","acc","Provider","displayName","Component","actions","reducers","selectors","createSelector","selector","contexts","map","filter","v","reducer","options","initial","name","Container","createContainer","React","useReducer","increment","Symbol","set","createReducer","counter","state","action","type","payload","useContainer","dispatch","Object","freeze","useCallback","value","add","clear","items","timeAsync","a","started","Date","now","request","Request","fetch","json","counterReducer","addAsync","time","props","createCombineProps","counterContext","Combine","DOM","onChangeCounter","onClickAdd","htmlFor","defaultValue","id","onChange","onClick","counterActions","e","Number","parseInt","currentTarget","useSideEffect","onClickClear","onClickFetch","length","index","key","fetchActions","fetchReducer","className","src","logo","alt","Counter","Fetch","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"gHAAAA,EAAOC,QAAU,IAA0B,kC,yJC+BrCC,G,MAAoC,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAH,IAAaC,UAAb,kBAAyB,GAAzB,GAC9BC,QACR,SAACC,EAAKC,GAAN,OAAmB,kBAACA,EAAD,KAAWD,KAC9B,oCAAGH,MAEPD,EAASM,YAAc,2BAQvB,IAAMC,EAA6B,SAAC,GAAD,IAAGC,EAAH,EAAGA,QAASP,EAAZ,EAAYA,SAAUQ,EAAtB,EAAsBA,SAAtB,OACjC,kBAAC,EAAD,CAAUP,UAAWO,GACnB,kBAAC,EAAD,CAAUP,UAAWM,GAAUP,KAGnCM,EAAUD,YAAc,mBAETC,QCxCTG,EAAa,WACjB,IAAMC,EAAiB,SACrBC,GADqB,OAElB,SAACC,GAAD,OACHA,EAASC,IAAIF,GAAUG,QAAO,SAACC,GAAD,QAAwBA,OACxD,MAAO,CAELR,QAASG,GAAe,qBAAGH,WAE3BC,SAAUE,GAAe,qBAAGM,YATb,G,qBC8CJ,WAAOC,GAAyC,IACrDC,EAA2BD,EAA3BC,QAASC,EAAkBF,EAAlBE,KAAMH,EAAYC,EAAZD,QACjBI,EAAYC,aAAgB,kBAAMC,IAAMC,WAAWP,EAASE,MAIlE,OAHIC,IACFC,EAAUhB,SAASC,YAAnB,oBAA8Cc,IAEzCC,GC5DII,EAAYC,OAAO,aAGnBC,EAAMD,OAAO,OAcXE,IAAoC,CACjDT,QAAS,CAAEU,QAAS,GACpBT,KAAM,UACNH,QAAS,SAACa,EAAOC,GACf,OAAQA,EAAOC,MACb,KAAKP,EACH,OAAO,2BAAKK,GAAZ,IAAmBD,QAASC,EAAMD,QAAU,IAC9C,KAAKF,EACH,OAAO,2BAAKG,GAAZ,IAAmBD,QAASE,EAAOE,UACrC,QACE,OAAOH,MCGTT,EAAYC,aAjBC,WAAM,MAIFL,EAAQiB,eAApBC,EAJc,oBAKvB,OAAOC,OAAOC,OAAgB,CAC5BZ,UAAWF,IAAMe,aAAY,kBAAMH,EAAS,CAAEH,KAAMP,MAAc,CAChEU,IAEFR,IAAKJ,IAAMe,aACT,SAACC,GAAD,OAAmBJ,EAAS,CAAEH,KAAML,EAAKM,QAASM,MAClD,CAACJ,SAOPd,EAAUhB,SAASC,YAAc,gBAElBe,QC/BAe,SAAOC,OAAiB,CACrC7B,QAASA,EAAQH,SACjBY,QAASA,EAAQZ,W,+BCJNmC,EAAMd,OAAO,OAEbe,EAAQf,OAAO,SAoBbE,IAAkC,CAC/CT,QAAS,CAAEuB,MAAO,IAClBtB,KAAM,QACNH,QAAS,SAACa,EAAOC,GACf,OAAQA,EAAOC,MACb,KAAKQ,EACH,OAAO,2BAAKV,GAAZ,IAAmBY,MAAM,GAAD,mBAAMZ,EAAMY,OAAZ,CAAmBX,EAAOE,YACpD,KAAKQ,EACH,OAAO,2BAAKX,GAAZ,IAAmBY,MAAO,KAC5B,QACE,OAAOZ,MCrBTa,EAAS,uCAAG,8BAAAC,EAAA,6DACVC,EAAUC,KAAKC,MAGfC,EAAU,IAAIC,QAAQ,6CAJZ,SAKHC,MAAMF,GALH,8BAKaG,OALb,gCAMTL,KAAKC,MAAQF,GANJ,2CAAH,qDA2BTxB,EAAYC,aAjBC,WAAO,IAAD,EACD8B,EAAelB,eAA5BL,EADc,oBACdA,QADc,EAKFZ,EAAQiB,eAApBC,EALc,oBAMvB,OAAOC,OAAOC,OAAgB,CAC5BgB,SAAU9B,IAAMe,YAAN,sBACR,sBAAAM,EAAA,kEACET,EADF,KACmBK,EADnB,SAC+CG,IAD/C,+BAC4Dd,EAD5D,MACmCyB,KADnC,KAC4DzB,QAD5D,YACaG,KADb,KACwBC,QADxB,mFAEA,CAACJ,EAASM,IAEZM,MAAOlB,IAAMe,aAAY,kBAAMH,EAAS,CAAEH,KAAMS,MAAU,CAACN,SAM/Dd,EAAUhB,SAASC,YAAc,cAElBe,QC9BTkC,EPcS,sCAAI1C,EAAJ,yBAAIA,EAAJ,uBACbuB,OAAOC,OAAc,CACnB7B,QAASE,EAAUF,QAAQK,GAC3BJ,SAAUC,EAAUD,SAASI,KOjBnB2C,CAAmBC,ECTlBrB,OAAOC,OAAiB,CACrC7B,QAASA,EAAQH,SACjBY,QAASA,EAAQZ,YDUbE,EAAsB,SAAC,GAAkB,IAAhBN,EAAe,EAAfA,SACrBO,EAAsB+C,EAAtB/C,QAASC,EAAa8C,EAAb9C,SACjB,OACE,kBAACiD,EAAD,CAASlD,QAASA,EAASC,SAAUA,GAClCR,IAIPM,EAAUD,YAAc,WAETC,Q,iBEXToD,EAA0B,SAAC,GAAD,IAAG9B,EAAH,EAAGA,QAAS+B,EAAZ,EAAYA,gBAAiBC,EAA7B,EAA6BA,WAA7B,OAC9B,iCACE,uCACW,gCAAShC,IAEpB,2BAAOiC,QAAQ,WAAf,eAEE,2BACEC,aAAclC,EACdmC,GAAG,UACH5C,KAAK,UACL6C,SAAUL,EACV5B,KAAK,YAGT,4BAAQkC,QAASL,EAAY7B,KAAK,UAAlC,QAKJ2B,EAAIrD,YAAc,aAGlB,IAgBMC,EAAuC,WAAO,IAAD,EAhB7B,WAAM,MAGC4D,EAAejC,eAAlCT,EAHkB,EAGlBA,UAAWE,EAHO,EAGPA,IAHO,EAIJyB,EAAelB,eAA5BL,EAJiB,oBAIjBA,QACT,OAAOO,OAAOC,OAAiB,CAC7BR,UACA+B,gBAAiBrC,IAAMe,aACrB,SAAC8B,GAAD,OAAOzC,EAAI0C,OAAOC,SAASF,EAAEG,cAAchC,MAAO,OAClD,CAACZ,IAEHkC,WAAYpC,IAMmC+C,GAAzC3C,EADyC,EACzCA,QAAS+B,EADgC,EAChCA,gBAAiBC,EADe,EACfA,WAClC,OACE,kBAAC,EAAD,CACEhC,QAASA,EACT+B,gBAAiBA,EACjBC,WAAYA,KAIlBtD,EAAUD,YAAc,UAETC,QCnDToD,EAA0B,SAAC,GAAD,QAC9BjB,aAD8B,MACtB,GADsB,EAE9B+B,EAF8B,EAE9BA,aACAC,EAH8B,EAG9BA,aAH8B,OAK9B,iCACE,4BAAQR,QAASQ,EAAc1C,KAAK,UAApC,uCAGA,4BAAQkC,QAASO,EAAczC,KAAK,UAApC,qBAGA,4BACGU,EAAMiC,OACLjC,EAAM5B,KAAI,WAAoB8D,GAApB,IAAG/C,EAAH,EAAGA,QAASyB,EAAZ,EAAYA,KAAZ,OAER,wBAAIuB,IAAKD,GAAT,WACU,gCAAStB,EAAT,MADV,wCAEE,gCAASzB,GAFX,cAMF,6CAKR8B,EAAIrD,YAAc,WAGlB,IAaMC,EAAuC,WAAO,IAAD,EAb7B,WAAM,MAGEuE,EAAa5C,eAAjCmB,EAHkB,EAGlBA,SAAUZ,EAHQ,EAGRA,MAHQ,EAINsC,EAAa7C,eAAxBQ,EAJiB,oBAIjBA,MACT,OAAON,OAAOC,OAAiB,CAC7BK,QACA+B,aAAchC,EACdiC,aAAcrB,IAM8BmB,GAAtC9B,EADyC,EACzCA,MAAO+B,EADkC,EAClCA,aAAcC,EADoB,EACpBA,aAC7B,OACE,kBAAC,EAAD,CACEhC,MAAOA,EACP+B,aAAcA,EACdC,aAAcA,KAIpBnE,EAAUD,YAAc,QAETC,QC/DTA,G,MAAsB,kBAC1B,kBAAC,EAAD,KACE,yBAAKyE,UAAU,OACb,4BAAQA,UAAU,cAChB,yBAAKC,IAAKC,IAAMF,UAAU,WAAWG,IAAI,SACzC,4CACA,kBAACC,EAAD,MACA,kBAACC,EAAD,WAKR9E,EAAUD,YAAc,MAETC,QCVK+E,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SD8HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAaC,gBAEdC,OAAM,SAACC,GACNC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.6d2db121.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\nimport type { ContainerProviderProps } from 'unstated-next';\n\n/** 基本形 HOC における、要求する型定義。 */\ninterface InternalProps {\n  /** コンテキスト プロバイダー一覧。 */\n  readonly providers?: readonly Provider[];\n}\n\n/** コンポーネントの要求する型定義。 */\nexport interface Props {\n  /**\n   * アクション コンテキストのプロバイダー一覧。\n   *\n   * リデューサー コンテキストの子要素としてレンダリング ツリーに繋ぐため、\n   * 全てのリデューサー コンテキストを参照することができます。\n   */\n  readonly actions?: readonly Provider[];\n  /**\n   * リデューサー コンテキストのプロバイダー一覧。\n   *\n   * 入れ子の上位としてレンダリング ツリーに繋ぐため、\n   * 全てのアクション コンテキストから参照することができます。\n   */\n  readonly reducers?: readonly Provider[];\n}\n\n/** コンテキストのプロバイダー型の短縮表記。 */\nexport type Provider = React.ComponentType<ContainerProviderProps>;\n\n/** プロバイダー一覧を結合して取り込むための、基本形となる HOC。 */\nconst Internal: React.FC<InternalProps> = ({ children, providers = [] }) =>\n  providers.reduce(\n    (acc, Provider) => <Provider>{acc}</Provider>,\n    <>{children}</>\n  );\nInternal.displayName = 'InternalCombinedContexts';\n\n/**\n * プロバイダー一覧を結合して取り込むコンポーネント。\n *\n * レンダリング ツリーの構造がリデューサー➡︎アクションとなるよう、\n * 入れ子状にしています。\n */\nconst Component: React.FC<Props> = ({ actions, children, reducers }) => (\n  <Internal providers={reducers}>\n    <Internal providers={actions}>{children}</Internal>\n  </Internal>\n);\nComponent.displayName = 'CombinedContexts';\n\nexport default Component;\n","import type { Props, Provider } from './Combine';\n\n/** コンテキストを登録する際における、オブジェクトの型定義。 */\nexport interface Register {\n  /** アクション コンテキストのプロバイダーを指定します。 */\n  readonly actions?: Provider;\n  /** リデューサー コンテキストのプロバイダーを指定します。 */\n  readonly reducer?: Provider;\n}\n\n/** `Register` の一覧から、特定条件のプロバイダー一覧を抽出するセレクター関数一覧。 */\nconst selectors = (() => {\n  const createSelector = (\n    selector: (register: Register) => Provider | undefined\n  ) => (contexts: readonly Register[]) =>\n    contexts.map(selector).filter((v): v is Provider => !!v);\n  return {\n    /** アクション コンテキスト一覧を抽出します。 */\n    actions: createSelector(({ actions }) => actions),\n    /** リデューサー コンテキスト一覧を抽出します。 */\n    reducers: createSelector(({ reducer }) => reducer),\n  } as const;\n})();\n\n/**\n * コンテキスト一覧から、結合に必要な属性一覧を作成します。\n * @param contexts コンテキスト一覧。\n */\nexport default (...contexts: readonly Register[]) =>\n  Object.freeze<Props>({\n    actions: selectors.actions(contexts),\n    reducers: selectors.reducers(contexts),\n  });\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\n\n/**\n * リデューサーへ渡す値の型定義。\n *\n * `P` の型を省略するか、`undefined` を指定した場合、ペイロードは\n * _optional_ となります。つまりペイロードの指定自体が省略可能となります。\n * @template T 識別子の型。\n * @template P ペイロードの型。\n */\nexport type Action<T extends PropertyKey, P = undefined> = Readonly<\n  ActionType<T> & (P extends undefined ? Partial<Payload<P>> : Payload<P>)\n>;\n\n/**\n * リデューサーへ渡す値における、識別子部分の型定義。\n * @template T 識別子の型。\n */\ninterface ActionType<T extends PropertyKey> {\n  /** 識別子。 */\n  readonly type: T;\n}\n\n/**\n * リデューサー コンテキストを作成するためのオプション一覧。\n * @template S 状態の型。\n * @template A アクションの型。\n */\nexport interface CreateReducerOptions<S, A> {\n  /** 初期状態。 */\n  readonly initial: Readonly<S>;\n  /**\n   * コンテキストをラッピングする、コンポーネント名。\n   *\n   * 省略しても問題ありませんが、デバッグ時に有用です。\n   */\n  readonly name?: string;\n  /** リデューサー関数。 */\n  readonly reducer: React.Reducer<S, A>;\n}\n\n/**\n * リデューサーへ渡す値における、ペイロード部分の型定義。\n * @template T ペイロードの型。\n */\ninterface Payload<T> {\n  /** ペイロード本体。 */\n  readonly payload: T;\n}\n\n/**\n * リデューサー コンテキストを作成します。\n * @template S 状態の型。\n * @template A アクションの型。\n * @param options オプション一覧。\n */\nexport default <S, A>(options: CreateReducerOptions<S, A>) => {\n  const { initial, name, reducer } = options;\n  const Container = createContainer(() => React.useReducer(reducer, initial));\n  if (name) {\n    Container.Provider.displayName = `[REDUCER] ${name}`;\n  }\n  return Container;\n};\n","import createReducer, { Action } from '../base/createReducer';\n\n/** カウンターのインクリメントを示す、識別定数。 */\nexport const increment = Symbol('increment');\n\n/** カウンターの上書きを示す、識別定数。 */\nexport const set = Symbol('set');\n\n/** カウンターの状態における、型定義。 */\nexport interface State {\n  /** カウンター。 */\n  readonly counter: number;\n}\n\n/** カウンター用のアクション パラメーター。 */\nexport type CounterAction =\n  | Action<typeof increment>\n  | Action<typeof set, number>;\n\n/** カウンター用のリデューサー コンテキスト。 */\nexport default createReducer<State, CounterAction>({\n  initial: { counter: 0 },\n  name: 'Counter',\n  reducer: (state, action) => {\n    switch (action.type) {\n      case increment:\n        return { ...state, counter: state.counter + 1 };\n      case set:\n        return { ...state, counter: action.payload };\n      default:\n        return state;\n    }\n  },\n});\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport reducer, { increment, set } from './reducer';\n\n/** カウンターにおける、アクションの型定義。 */\nexport interface Actions {\n  /** カウンターをインクリメントします。 */\n  readonly increment: () => void;\n  /** カウンターを指定の値で上書きします。 */\n  readonly set: (\n    /** 値。 */\n    value: number\n  ) => void;\n}\n\n/** カウンターにおける、アクションを作成します。 */\nconst useActions = () => {\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    increment: React.useCallback(() => dispatch({ type: increment }), [\n      dispatch,\n    ]),\n    set: React.useCallback(\n      (value: number) => dispatch({ type: set, payload: value }),\n      [dispatch]\n    ),\n  });\n};\n\n/** カウンターにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'CounterAction';\n\nexport default Container;\n","import type { Register } from '../base/createCombineProps';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nexport default Object.freeze<Register>({\n  actions: actions.Provider,\n  reducer: reducer.Provider,\n});\n","import createReducer, { Action } from '../base/createReducer';\n\n/** フェッチ ログの追加を示す、識別定数。 */\nexport const add = Symbol('add');\n/** フェッチ ログの全件削除を示す、識別定数。 */\nexport const clear = Symbol('clear');\n\n/** フェッチ ログの単体構造。 */\nexport interface Item {\n  /** 通信の所要時間を、ミリ秒単位で格納します。 */\n  readonly time: number;\n  /** 通信時における、カウンター値。 */\n  readonly counter: number;\n}\n\n/** フェッチ ログ状態における、型定義。 */\nexport interface State {\n  /** フェッチ ログ一覧。 */\n  readonly items: readonly Item[];\n}\n\n/** フェッチ用のアクション パラメーター。 */\nexport type FetchAction = Action<typeof add, Item> | Action<typeof clear>;\n\n/** フェッチ用のリデューサー コンテキスト。 */\nexport default createReducer<State, FetchAction>({\n  initial: { items: [] },\n  name: 'Fetch',\n  reducer: (state, action) => {\n    switch (action.type) {\n      case add:\n        return { ...state, items: [...state.items, action.payload] };\n      case clear:\n        return { ...state, items: [] };\n      default:\n        return state;\n    }\n  },\n});\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport counterReducer from '../counter/reducer';\nimport reducer, { add, clear } from './reducer';\n\n/** フェッチ ログにおける、アクションの型定義。 */\nexport interface Actions {\n  /** 非同期的にフェッチを行い、経過時間やその時のカウンター値をログに追加します。 */\n  readonly addAsync: () => Promise<void>;\n  /** フェッチ ログを全件削除します。 */\n  readonly clear: () => void;\n}\n\n/** 非同期的にフェッチを行い、所要時間をミリ秒単位で取得します。 */\nconst timeAsync = async () => {\n  const started = Date.now();\n  // 単に繋いでいる間待つだけ。単に非同期で動くことを検証したい\n  // だけの代物なので、ダミーウェイトで代用しても構わない。\n  const request = new Request('https://api.github.com/users/danmaq/repos');\n  await (await fetch(request)).json();\n  return Date.now() - started;\n};\n\n/** フェッチ ログにおける、アクションを作成します。 */\nconst useActions = () => {\n  const [{ counter }] = counterReducer.useContainer();\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    addAsync: React.useCallback(\n      async () =>\n        dispatch({ type: add, payload: { time: await timeAsync(), counter } }),\n      [counter, dispatch]\n    ),\n    clear: React.useCallback(() => dispatch({ type: clear }), [dispatch]),\n  });\n};\n\n/** フェッチ ログにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'FetchAction';\n\nexport default Container;\n","import React from 'react';\nimport Combine from './base/Combine';\nimport createCombineProps from './base/createCombineProps';\nimport counterContext from './counter';\nimport fetchContext from './fetch';\n\n/**\n * コンテキスト一覧。\n *\n * 別のコンテキストを追加する場合、ここに挿入します。\n *\n * 同一ヒエラルキーのコンテキストを参照したい場合、\n * 参照対象より末尾に指定します。\n */\nconst props = createCombineProps(counterContext, fetchContext);\n\n/** コンテキスト一覧をレンダリング ツリーに結合するための HOC。 */\nconst Component: React.FC = ({ children }) => {\n  const { actions, reducers } = props;\n  return (\n    <Combine actions={actions} reducers={reducers}>\n      {children}\n    </Combine>\n  );\n};\nComponent.displayName = 'Contexts';\n\nexport default Component;\n","import type { Register } from '../base/createCombineProps';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nexport default Object.freeze<Register>({\n  actions: actions.Provider,\n  reducer: reducer.Provider,\n});\n","import React from 'react';\nimport counterActions from '../hooks/contexts/counter/actions';\nimport counterReducer from '../hooks/contexts/counter/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** カウンターの値。 */\n  readonly counter: number;\n  /** カウンターを直接編集した際のコールバック。 */\n  readonly onChangeCounter?: React.ChangeEventHandler<HTMLInputElement>;\n  /** `+1` ボタンを押下した際のコールバック。 */\n  readonly onClickAdd?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\n/** カウンター表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({ counter, onChangeCounter, onClickAdd }) => (\n  <section>\n    <p>\n      Counter: <strong>{counter}</strong>\n    </p>\n    <label htmlFor=\"counter\">\n      Set counter:\n      <input\n        defaultValue={counter}\n        id=\"counter\"\n        name=\"counter\"\n        onChange={onChangeCounter}\n        type=\"number\"\n      />\n    </label>\n    <button onClick={onClickAdd} type=\"button\">\n      +1\n    </button>\n  </section>\n);\nDOM.displayName = 'CounterDOM';\n\n/** カウンター表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { increment, set } = counterActions.useContainer();\n  const [{ counter }] = counterReducer.useContainer();\n  return Object.freeze<DOMProps>({\n    counter,\n    onChangeCounter: React.useCallback(\n      (e) => set(Number.parseInt(e.currentTarget.value, 10)),\n      [set]\n    ),\n    onClickAdd: increment,\n  });\n};\n\n/** 副作用と結合した、カウンター表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const { counter, onChangeCounter, onClickAdd } = useSideEffect();\n  return (\n    <DOM\n      counter={counter}\n      onChangeCounter={onChangeCounter}\n      onClickAdd={onClickAdd}\n    />\n  );\n};\nComponent.displayName = 'Counter';\n\nexport default Component;\n","import React from 'react';\nimport fetchActions from '../hooks/contexts/fetch/actions';\nimport fetchReducer, { Item } from '../hooks/contexts/fetch/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** フェッチ結果一覧。 */\n  readonly items?: readonly Item[];\n  /** 一覧消去のボタンを押下した際における、コールバック。 */\n  readonly onClickClear?: React.MouseEventHandler<HTMLButtonElement>;\n  /** フェッチ ボタンを押下した際における、コールバック。 */\n  readonly onClickFetch?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\n/** フェッチ表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({\n  items = [],\n  onClickClear,\n  onClickFetch,\n}) => (\n  <section>\n    <button onClick={onClickFetch} type=\"button\">\n      Fetch to “api.github.com”\n    </button>\n    <button onClick={onClickClear} type=\"button\">\n      Clear the history\n    </button>\n    <ol>\n      {items.length ? (\n        items.map(({ counter, time }, index) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={index}>\n            It took <strong>{time}ms</strong> to fetch, and the counter was “\n            <strong>{counter}</strong>”.\n          </li>\n        ))\n      ) : (\n        <li>Empty data</li>\n      )}\n    </ol>\n  </section>\n);\nDOM.displayName = 'FetchDOM';\n\n/** フェッチ表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { addAsync, clear } = fetchActions.useContainer();\n  const [{ items }] = fetchReducer.useContainer();\n  return Object.freeze<DOMProps>({\n    items,\n    onClickClear: clear,\n    onClickFetch: addAsync,\n  });\n};\n\n/** 副作用と結合した、フェッチ表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const { items, onClickClear, onClickFetch } = useSideEffect();\n  return (\n    <DOM\n      items={items}\n      onClickClear={onClickClear}\n      onClickFetch={onClickFetch}\n    />\n  );\n};\nComponent.displayName = 'Fetch';\n\nexport default Component;\n","import React from 'react';\nimport Contexts from '../hooks/contexts';\nimport logo from './logo.svg';\nimport Counter from './Counter';\nimport Fetch from './Fetch';\nimport './App.css';\n\n/** ルート要素 コンポーネント。 */\nconst Component: React.FC = () => (\n  <Contexts>\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>Hello, world!</p>\n        <Counter />\n        <Fetch />\n      </header>\n    </div>\n  </Contexts>\n);\nComponent.displayName = 'App';\n\nexport default Component;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Component from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Component />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}