{"version":3,"sources":["hooks/contexts/base/Combine.tsx","logics/renderLayers.ts","hooks/contexts/base/combineReducer.ts","hooks/contexts/base/order.ts","hooks/contexts/base/createReducer.ts","hooks/contexts/form/reducer/counter.ts","hooks/contexts/form/reducer/text.ts","hooks/contexts/form/reducer/index.ts","hooks/contexts/fetch/reducer.ts","hooks/contexts/fetch/actions.ts","hooks/contexts/fetch/index.ts","hooks/contexts/foo.ts","hooks/contexts/form/actions.ts","hooks/contexts/index.tsx","hooks/contexts/form/index.ts","components/logo.svg","components/Fetch.tsx","components/Form.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["Component","children","providers","reduceRight","acc","Provider","displayName","order","options","REDUCER","Symbol","ACTIONS","INTEGRATED","renderLayers","layers","reduce","key","list","flatMap","x","useReducerState","container","useContainer","deepReducer","reducer","Object","freeze","state","action","prev","next","isEqual","deepEquals","initial","name","createContainer","React","useReducer","increment","set","counter","type","payload","text","source","createReducer","keys","createCombinedSource","add","clear","items","timeAsync","a","started","Date","now","request","Request","fetch","json","Container","formReducer","dispatch","addAsync","useCallback","time","actions","useEffect","console","log","setCounter","value","setText","fetchContext","fooContext","Combine","DOM","onClickClear","onClickFetch","onClick","length","map","index","fetchActions","fetchReducer","useSideEffect","onChangeCounter","onChangeText","onClickAdd","htmlFor","defaultValue","id","onChange","e","Number","parseInt","currentTarget","className","src","logo","alt","Form","Fetch","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ca1653e1.chunk.js","sourcesContent":["import React from 'react';\nimport type { ContainerProviderProps } from 'unstated-next';\n\n/** コンポーネントの要求する型定義。 */\nexport interface Props {\n  /** コンテキスト プロバイダー一覧。 */\n  readonly providers?: readonly Provider[];\n}\n\n/** コンテキストのプロバイダー型の短縮表記。 */\nexport type Provider = React.ComponentType<ContainerProviderProps>;\n\n/** プロバイダー一覧を単純結合する HOC コンポーネント。 */\nconst Component: React.FC<Props> = ({ children, providers = [] }) =>\n  // Decorator パターンのように、後の要素をラッピングしていく構造のため、`reduceRight` で反転している。\n  providers.reduceRight(\n    (acc, Provider) => <Provider>{acc}</Provider>,\n    <>{children}</>\n  );\nComponent.displayName = 'Combine';\n\nexport default Component;\n","/**\n * レイヤー構造として要求する型定義。\n * @template R レイヤーの優先度として、使用する型。\n * @template T レイヤー本体の型。\n */\nexport type Layer<R extends PropertyKey, T> = Readonly<\n  Partial<Record<R, T | readonly T[]>>\n>;\n\n/**\n * 指定した引数をルールに、レイヤー結合関数を生成します。\n * @template R レイヤーの優先度として、使用する型。\n *\n * キーとして列挙可能な型のみ使用可能です。\n * @param order ルールとするレイヤー定義と優先度を示した配列。\n *\n * インデックスが先頭の要素ほど、先頭に配置します。\n */\nexport default <R extends PropertyKey>(order: readonly R[]) =>\n  /**\n   * レイヤーを結合して、単一の配列を生成します。\n   * @template T レイヤーの型。\n   * @param layers レイヤー別に分類した、値もしくは値の一覧。\n   */\n  <T>(...layers: Layer<R, T>[]) =>\n    order.reduce<T[]>((acc, key) => {\n      const list = layers.flatMap((x): T | readonly T[] => x[key] ?? []);\n      return [...acc, ...list];\n    }, []);\n","import type React from 'react';\nimport createReducer, {\n  AbstractReducer,\n  Options,\n  Source as ItemSource,\n} from './createReducer';\n\n/** 抽象化したリデューサーと初期状態とのペア一覧における、型定義のシノニム。 */\ntype AbstractSource = Record<string, ItemSource<AbstractReducer>>;\n\n/**\n * 結合した状態の型定義。\n * @template T リデューサーと初期状態とのペアの型。\n */\nexport type CombinedState<T extends Source<AbstractSource>> = {\n  readonly [k in keyof T]: T[k]['initial'];\n};\n\n/**\n * ソースとなる、リデューサーと初期状態とのペアの型。\n * @template T 値の型。\n */\nexport type Source<T extends AbstractSource> = T;\n\n/**\n * 結合した、`createReducer` 関数のソースを作成します。\n * @template A 結合したリデューサー アクションの型。\n * @template S ソースとなる、リデューサーと初期状態とのペア一覧の型。\n * @param source ソースとなる、リデューサーと初期状態とのペア一覧。\n */\nconst createCombinedSource = <A, S extends AbstractSource>(\n  source: Source<S>\n) => {\n  type State = CombinedState<typeof source>;\n  const keys = Object.keys(source) as readonly (keyof typeof source)[];\n  return Object.freeze<ItemSource<React.Reducer<CombinedState<S>, A>>>({\n    initial: keys.reduce<State>(\n      (acc, key) => ({ ...acc, [key]: source[key].initial }),\n      {} as State\n    ),\n    reducer: (state, action) =>\n      keys.reduce(\n        (acc, key) => ({\n          ...acc,\n          [key]: source[key].reducer(acc[key], action),\n        }),\n        state\n      ),\n  });\n};\n\n/**\n * 結合済みリデューサー コンテキストを作成する関数を生成します。\n * @template T 結合したリデューサー アクションの型。\n * @param options オプション一覧。\n */\nexport default <T>(options?: Options) =>\n  /**\n   * 結合済みリデューサー コンテキストを作成します。\n   * @template S ソースとなる、リデューサーと初期状態とのペア一覧の型。\n   * @param source ソースとなる、リデューサーと初期状態とのペア一覧。\n   */\n  <S extends AbstractSource>(source: Source<S>) =>\n    createReducer<CombinedState<typeof source>, T>({\n      ...options,\n      ...createCombinedSource(source),\n    });\n","import renderLayers, { Layer } from '../../../logics/renderLayers';\n\n/** リデューサー コンテキストのレイヤーを示す定数。 */\nexport const REDUCER = Symbol('reducer');\n\n/** アクション コンテキストのレイヤーを示す定数。 */\nexport const ACTIONS = Symbol('actions');\n\n/**\n * 結合のための上位アクション コンテキストのレイヤーを示す定数。\n *\n * _注意: この定数を使用する前に、極力 `ACTIONS` の使用を検討してください。_\n */\nexport const INTEGRATED = Symbol('integrated');\n\n/**\n * レイヤー結合のための優先度ルール。\n *\n * インデックスが若いものほど、より上位のレイヤーとなります。\n *\n * 新しいレイヤー階層が必要である場合、ここに追加していきます。\n */\nconst orderRule = [REDUCER, ACTIONS, INTEGRATED] as const;\n\n/**\n * レイヤー構造として要求する型定義。\n * @template T レイヤー本体の型。\n */\nexport type ConcretedLayer<T> = Layer<typeof orderRule[number], T>;\n\nexport default renderLayers(orderRule);\n","import isEqual from 'lodash/isEqual';\nimport React from 'react';\nimport { createContainer, Container } from 'unstated-next';\n\n/** 抽象化したリデューサー関数における、型定義のシノニム。 */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbstractReducer = React.Reducer<any, any>;\n\n/**\n * リデューサーへ渡す値の型定義。\n *\n * `P` の型を省略するか、`undefined` を指定した場合、ペイロードは\n * _optional_ となります。つまりペイロードの指定自体が省略可能となります。\n * @template T 識別子の型。\n * @template P ペイロードの型。\n */\nexport type Action<T, P = undefined> = Readonly<\n  ActionType<T> &\n    (P extends undefined ? Partial<ActionPayload<P>> : ActionPayload<P>)\n>;\n\n/**\n * リデューサーへ渡す値における、ペイロード部分の型定義。\n * @template T ペイロードの型。\n */\ninterface ActionPayload<T> {\n  /** ペイロード本体。 */\n  readonly payload: T;\n}\n\n/**\n * リデューサーへ渡す値における、識別子部分の型定義。\n * @template T 識別子の型。\n */\ninterface ActionType<T> {\n  /** 識別子。 */\n  readonly type: T;\n}\n\n/**\n * リデューサー コンテキストを作成するための、任意のオプション一覧。\n * @template R リデューサー関数の型。\n */\nexport interface Options {\n  /**\n   * 状態を更新するために深い比較を用いるかどうか。\n   *\n   * 省略時や `false` 指定時は、React 既定の浅い比較を用います。\n   */\n  readonly deepEquals?: boolean;\n  /**\n   * コンテキストをラッピングする、コンポーネント名。\n   *\n   * 省略しても問題ありませんが、デバッグ時に有用です。\n   */\n  readonly name?: string;\n}\n\n/**\n * リデューサー関数と初期状態とのペア。\n * @template R リデューサー関数の型。\n */\nexport interface Source<R extends AbstractReducer> {\n  /** 初期状態。 */\n  readonly initial: React.ReducerState<R>;\n  /** リデューサー関数。 */\n  readonly reducer: R;\n}\n\n/**\n * 状態のプロパティーにアクセスします。\n * @template S 状態の型。\n * @param container コンテナー。\n * @param key 状態のプロパティ名。\n */\nexport const useReducerState = <S, K extends keyof S>(\n  container: Container<[S, unknown], void>,\n  key: K\n) => {\n  const [state] = container.useContainer();\n  return state[key];\n};\n\n/**\n * 状態の深い比較をし、相違があるなら新しい状態、そうでないなら古い状態を取得します。\n * @template T 状態の型。\n * @param prev 古い状態。\n * @param next 新しい状態。\n */\nexport const select = <T>(prev: T, next: T) =>\n  isEqual(prev, next) ? prev : next;\n\n/**\n * 状態の深い比較をするリデューサー関数を作成します。\n * @template S 状態の型。\n * @template A アクションの型。\n * @param reducer リデューサー関数。\n *\n * この関数の戻り値に対し、深い比較を行います。\n */\nconst deepReducer = <S, A>(reducer: React.Reducer<S, A>) =>\n  Object.freeze<React.Reducer<S, A>>((state, action) =>\n    select(state, reducer(state, action))\n  );\n\n/**\n * リデューサー コンテキストを作成します。\n * @template S 状態の型。\n * @template A アクションの型。\n * @param options オプション一覧。\n */\nexport default <S, A>(options: Options & Source<React.Reducer<S, A>>) => {\n  const { deepEquals, initial, name, reducer } = options;\n  const container = createContainer(() =>\n    React.useReducer(deepEquals ? deepReducer(reducer) : reducer, initial)\n  );\n  if (name) {\n    container.Provider.displayName = `[REDUCER] ${name}`;\n  }\n  return container;\n};\n","import type React from 'react';\nimport type { Action, Source } from '../../base/createReducer';\n\n/** カウンターのインクリメントを示す、識別定数。 */\nexport const increment = Symbol('increment');\n\n/** カウンターの上書きを示す、識別定数。 */\nexport const set = Symbol('set');\n\n/** カウンターの状態における、型定義。 */\nexport interface CounterState {\n  /** カウンター。 */\n  readonly counter: number;\n}\n\n/** カウンター用のアクション パラメーター。 */\nexport type CounterAction =\n  | Action<typeof increment>\n  | Action<typeof set, number>;\n\n/**\n * リデューサー関数。\n * @param state 直近の状態。\n * @param action ディスパッチ アクションのパラメーター。\n */\nconst reducer: React.Reducer<CounterState, CounterAction> = (state, action) => {\n  switch (action.type) {\n    case increment:\n      return { ...state, counter: state.counter + 1 };\n    case set:\n      return { ...state, counter: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport default Object.freeze<Source<typeof reducer>>({\n  initial: { counter: 0 },\n  reducer,\n});\n","import type React from 'react';\nimport type { Action, Source } from '../../base/createReducer';\n\n/** 文字列の上書きを示す、識別定数。 */\nexport const set = Symbol('set');\n\n/** 文字列の状態における、型定義。 */\nexport interface TextState {\n  /** 文字列。 */\n  readonly text: string;\n}\n\n/** 文字列用のアクション パラメーター。 */\nexport type TextAction = Action<typeof set, string>;\n\n/**\n * リデューサー関数。\n * @param state 直近の状態。\n * @param action ディスパッチ アクションのパラメーター。\n */\nconst reducer: React.Reducer<TextState, TextAction> = (state, action) => {\n  switch (action.type) {\n    case set:\n      return { ...state, text: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport default Object.freeze<Source<typeof reducer>>({\n  initial: { text: '' },\n  reducer,\n});\n","import { useReducerState } from '../../base/createReducer';\nimport combineReducer, { CombinedState } from '../../base/combineReducer';\nimport counter, { CounterAction } from './counter';\nimport text, { TextAction } from './text';\n\n/** フォーム用に結合するリデューサー一覧。 */\nconst list = { counter, text } as const;\n\nexport type State = CombinedState<typeof list>;\n\n/** フォーム用の結合済みリデューサー アクションにおける型定義。 */\nexport type DispatchAction = CounterAction | TextAction;\n\n/** フォーム用の結合済みリデューサー コンテキスト。 */\nconst reducer = combineReducer<DispatchAction>({\n  deepEquals: true,\n  name: 'Form',\n})(list);\n\n/** カウンターにアクセスするためのカスタムフック。 */\nexport const useCounter = () => useReducerState(reducer, 'counter');\n\n/** テキストにアクセスするためのカスタムフック。 */\nexport const useText = () => useReducerState(reducer, 'text');\n\nexport default reducer;\n","import createReducer, { Action } from '../base/createReducer';\n\n/** フェッチ ログの追加を示す、識別定数。 */\nexport const add = Symbol('add');\n/** フェッチ ログの全件削除を示す、識別定数。 */\nexport const clear = Symbol('clear');\n\n/** フェッチ ログの単体構造。 */\nexport interface Item {\n  /** 通信の所要時間を、ミリ秒単位で格納します。 */\n  readonly time: number;\n  /** 通信時における、カウンター値。 */\n  readonly counter: number;\n}\n\n/** フェッチ ログ状態における、型定義。 */\nexport interface State {\n  /** フェッチ ログ一覧。 */\n  readonly items: readonly Item[];\n}\n\n/** フェッチ用のアクション パラメーター。 */\nexport type FetchAction = Action<typeof add, Item> | Action<typeof clear>;\n\n/** フェッチ用のリデューサー コンテキスト。 */\nexport default createReducer<State, FetchAction>({\n  initial: { items: [] },\n  name: 'Fetch',\n  reducer: (state, action) => {\n    switch (action.type) {\n      case add:\n        return { ...state, items: [...state.items, action.payload] };\n      case clear:\n        return { ...state, items: [] };\n      default:\n        return state;\n    }\n  },\n});\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport formReducer from '../form/reducer';\nimport reducer, { add, clear } from './reducer';\n\n/** フェッチ ログにおける、アクションの型定義。 */\nexport interface Actions {\n  /** 非同期的にフェッチを行い、経過時間やその時のカウンター値をログに追加します。 */\n  readonly addAsync: () => Promise<void>;\n  /** フェッチ ログを全件削除します。 */\n  readonly clear: () => void;\n}\n\n/** 非同期的にフェッチを行い、所要時間をミリ秒単位で取得します。 */\nconst timeAsync = async () => {\n  const started = Date.now();\n  // 単に繋いでいる間待つだけ。単に非同期で動くことを検証したい\n  // だけの代物なので、ダミーウェイトで代用しても構わない。\n  const request = new Request('https://api.github.com/users/danmaq/repos');\n  await (await fetch(request)).json();\n  return Date.now() - started;\n};\n\n/** フェッチ ログにおける、アクションを作成します。 */\nconst useActions = () => {\n  const [{ counter }] = formReducer.useContainer();\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    addAsync: React.useCallback(\n      async () =>\n        dispatch({\n          type: add,\n          payload: { time: await timeAsync(), counter: counter.counter },\n        }),\n      [counter.counter, dispatch]\n    ),\n    clear: React.useCallback(() => dispatch({ type: clear }), [dispatch]),\n  });\n};\n\n/** フェッチ ログにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'FetchAction';\n\nexport default Container;\n","import type { Provider } from '../base/Combine';\nimport { ACTIONS, ConcretedLayer, REDUCER } from '../base/order';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nconst layers: ConcretedLayer<Provider> = {\n  [ACTIONS]: actions.Provider,\n  [REDUCER]: reducer.Provider,\n};\n\nexport default layers;\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport type { Provider } from './base/Combine';\nimport { ACTIONS, ConcretedLayer } from './base/order';\n\n/** エフェクトのみで、コンテキストとしての機能を何も提供しないアクション。 */\nconst Container = createContainer(() =>\n  // eslint-disable-next-line no-console\n  React.useEffect(() => console.log('** Effected the foo! **'), [])\n);\nContainer.Provider.displayName = 'FooAction';\n\n/** コンテキストの結合用オブジェクト。 */\nconst layers: ConcretedLayer<Provider> = { [ACTIONS]: Container.Provider };\n\nexport default layers;\n","import React from 'react';\nimport { createContainer } from 'unstated-next';\nimport reducer from './reducer';\nimport { increment, set as setCounter } from './reducer/counter';\nimport { set as setText } from './reducer/text';\n\n/** フォームにおける、アクションの型定義。 */\nexport interface Actions {\n  /** カウンターをインクリメントします。 */\n  readonly increment: () => void;\n  /** カウンターを指定の値で上書きします。 */\n  readonly setCounter: (\n    /** 値。 */\n    value: number\n  ) => void;\n  /** カウンターを指定の値で上書きします。 */\n  readonly setText: (\n    /** 値。 */\n    value: string\n  ) => void;\n}\n\n/** フォームにおける、アクションを作成します。 */\nconst useActions = () => {\n  // see: https://ja.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n  // > useReducer から返される dispatch 関数は常に同一性が保たれます。\n  // この主張を信用し、各メモ化工程で dispatch を deps 指定しています。\n  const [, dispatch] = reducer.useContainer();\n  return Object.freeze<Actions>({\n    increment: React.useCallback(() => dispatch({ type: increment }), [\n      dispatch,\n    ]),\n    setCounter: React.useCallback(\n      (value: number) => dispatch({ type: setCounter, payload: value }),\n      [dispatch]\n    ),\n    setText: React.useCallback(\n      (value: string) => dispatch({ type: setText, payload: value }),\n      [dispatch]\n    ),\n  });\n};\n\n/** フォームにおける、アクション コンテキスト。 */\nconst Container = createContainer(useActions);\nContainer.Provider.displayName = 'FormAction';\n\nexport default Container;\n","import React from 'react';\nimport CombinedContexts from './base/Combine';\nimport order from './base/order';\nimport fetchContext from './fetch';\nimport fooContext from './foo';\nimport formContext from './form';\n\n/**\n * コンテキスト一覧。\n *\n * 別のコンテキストを追加する場合、ここに挿入します。\n *\n * 同一ヒエラルキーのコンテキストを参照したい場合、\n * 参照対象より末尾に指定します。\n */\nconst providers = order(fetchContext, fooContext, formContext);\n\n/** コンテキスト一覧をレンダリング ツリーに結合するための HOC。 */\nconst Component: React.FC = ({ children }) => (\n  <CombinedContexts providers={providers}>{children}</CombinedContexts>\n);\nComponent.displayName = 'Contexts';\n\nexport default Component;\n","import type { Provider } from '../base/Combine';\nimport { ACTIONS, ConcretedLayer, REDUCER } from '../base/order';\nimport actions from './actions';\nimport reducer from './reducer';\n\n/** コンテキストの結合用オブジェクト。 */\nconst layers: ConcretedLayer<Provider> = {\n  [ACTIONS]: actions.Provider,\n  [REDUCER]: reducer.Provider,\n};\n\nexport default layers;\n","export default __webpack_public_path__ + \"static/media/logo.103b5fa1.svg\";","import React from 'react';\nimport fetchActions from '../hooks/contexts/fetch/actions';\nimport fetchReducer, { Item } from '../hooks/contexts/fetch/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** フェッチ結果一覧。 */\n  readonly items?: readonly Item[];\n  /** 一覧消去のボタンを押下した際における、コールバック。 */\n  readonly onClickClear?: React.MouseEventHandler<HTMLButtonElement>;\n  /** フェッチ ボタンを押下した際における、コールバック。 */\n  readonly onClickFetch?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\n/** フェッチ表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({\n  items = [],\n  onClickClear,\n  onClickFetch,\n}) => (\n  <section>\n    <button onClick={onClickFetch} type=\"button\">\n      Fetch to “api.github.com”\n    </button>\n    <button onClick={onClickClear} type=\"button\">\n      Clear the history\n    </button>\n    <ol>\n      {items.length ? (\n        items.map(({ counter, time }, index) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={index}>\n            It took <strong>{time}ms</strong> to fetch, and the counter was “\n            <strong>{counter}</strong>”.\n          </li>\n        ))\n      ) : (\n        <li>Empty data</li>\n      )}\n    </ol>\n  </section>\n);\nDOM.displayName = 'FetchDOM';\n\n/** フェッチ表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { addAsync, clear } = fetchActions.useContainer();\n  const [{ items }] = fetchReducer.useContainer();\n  return Object.freeze<DOMProps>({\n    items,\n    onClickClear: clear,\n    onClickFetch: addAsync,\n  });\n};\n\n/** 副作用と結合した、フェッチ表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const { items, onClickClear, onClickFetch } = useSideEffect();\n  return (\n    <DOM\n      items={items}\n      onClickClear={onClickClear}\n      onClickFetch={onClickFetch}\n    />\n  );\n};\nComponent.displayName = 'Fetch';\n\nexport default Component;\n","import React from 'react';\nimport actions from '../hooks/contexts/form/actions';\nimport { useCounter, useText } from '../hooks/contexts/form/reducer';\nimport type { WithoutChildren } from './types';\n\n/** DOM 要素のための型定義。 */\ninterface DOMProps extends WithoutChildren {\n  /** カウンターの値。 */\n  readonly counter: number;\n  /** カウンターを直接編集した際のコールバック。 */\n  readonly onChangeCounter?: React.ChangeEventHandler<HTMLInputElement>;\n  /** テキストを直接編集した際のコールバック。 */\n  readonly onChangeText?: React.ChangeEventHandler<HTMLInputElement>;\n  /** `+1` ボタンを押下した際のコールバック。 */\n  readonly onClickAdd?: React.MouseEventHandler<HTMLButtonElement>;\n  /** テキストの値。 */\n  readonly text: string;\n}\n\n/** フォーム表示のための、副作用を持たない DOM 要素。 */\nconst DOM: React.FC<DOMProps> = ({\n  counter,\n  onChangeCounter,\n  onChangeText,\n  onClickAdd,\n  text,\n}) => (\n  <section>\n    <p>\n      Value: <strong>{counter}</strong> ({text})\n    </p>\n    <div>\n      <label htmlFor=\"counter\">\n        Set counter:\n        <input\n          defaultValue={counter}\n          id=\"counter\"\n          name=\"counter\"\n          onChange={onChangeCounter}\n          type=\"number\"\n        />\n      </label>\n      <button onClick={onClickAdd} type=\"button\">\n        +1\n      </button>\n    </div>\n    <div>\n      <label htmlFor=\"text\">\n        Set text:\n        <input\n          defaultValue={text}\n          id=\"text\"\n          name=\"text\"\n          onChange={onChangeText}\n          type=\"text\"\n        />\n      </label>\n    </div>\n  </section>\n);\nDOM.displayName = 'CounterDOM';\n\n/** フォーム表示・制御のための、副作用を取得するためのカスタムフック。 */\nconst useSideEffect = () => {\n  // ここでは Actions・Reducer 双方にアクセスできる。\n  // Reducer への直接 Dispatch も一応可能だが、Actions を介する方が行儀良い。\n  const { increment, setCounter, setText } = actions.useContainer();\n  const { counter } = useCounter();\n  const { text } = useText();\n  return Object.freeze<DOMProps>({\n    counter,\n    onChangeCounter: React.useCallback(\n      (e) => setCounter(Number.parseInt(e.currentTarget.value, 10)),\n      [setCounter]\n    ),\n    onChangeText: React.useCallback((e) => setText(e.currentTarget.value), [\n      setText,\n    ]),\n    onClickAdd: increment,\n    text,\n  });\n};\n\n/** 副作用と結合した、フォーム表示＆制御コンポーネント。 */\nconst Component: React.FC<WithoutChildren> = () => {\n  const {\n    counter,\n    onChangeCounter,\n    onChangeText,\n    onClickAdd,\n    text,\n  } = useSideEffect();\n  return (\n    <DOM\n      counter={counter}\n      onChangeCounter={onChangeCounter}\n      onChangeText={onChangeText}\n      onClickAdd={onClickAdd}\n      text={text}\n    />\n  );\n};\nComponent.displayName = 'Counter';\n\nexport default Component;\n","import React from 'react';\nimport Contexts from '../hooks/contexts';\nimport logo from './logo.svg';\nimport Fetch from './Fetch';\nimport Form from './Form';\nimport './App.css';\n\n/** ルート要素 コンポーネント。 */\nconst Component: React.FC = () => (\n  <Contexts>\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>Hello, world!</p>\n        <Form />\n        <Fetch />\n      </header>\n    </div>\n  </Contexts>\n);\nComponent.displayName = 'App';\n\nexport default Component;\n","/* eslint-disable no-console */\n\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nconst registerValidSW = (swUrl: string, config?: Config) => {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      // eslint-disable-next-line no-param-reassign\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (!installingWorker) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config?.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config?.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) =>\n      console.error('Error during service worker registration:', error)\n    );\n};\n\nconst checkValidServiceWorker = (swUrl: string, config?: Config) => {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, { headers: { 'Service-Worker': 'script' } })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready\n          .then((registration) => registration.unregister())\n          .then(() => window.location.reload());\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() =>\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    );\n};\n\nexport const register = (config?: Config) => {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() =>\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        );\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n};\n\nexport const unregister = () => {\n  if (!('serviceWorker' in navigator)) {\n    return;\n  }\n  navigator.serviceWorker.ready\n    .then((registration) => registration.unregister())\n    .catch((error) => console.error(error.message));\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Component from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Component />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}